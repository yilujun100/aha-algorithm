/**
 * 数的全排列
 * 123的全排列是：123 132 213 231 312 321
 * 这个例子饱含深度优先搜索(Depth First Search, DFS)的基本模型。理解深度优先搜索的关键在于解决"当下该如何做"。至于"下一步如何做"则与"当下该如何做"是一样的。
 * 比如我们这里写的dfs(step)函数的主要功能就是解决当你在第step个盒子的时候你该怎么办。通常的方法就是把每一种可能都去尝试一遍(一般使用for循环来遍历)。当前这一步
 * 解决后便进入下一步dfs(step+1)。下一步的解决方法和当前步的解决方法是完全一样的。
 */

/**
 * 数的全排列
 * @param {number} n 取值范围为1~9
 */
function permutationNumbers(n) {
    let a = [] // a用来表示小盒子
    const book = new Array(10).fill(0) // book用来标记哪些牌已经使用了

    const dfs = step => { // step表示现在站在第几个盒子面前
        let i
        if (step === n + 1) { // 如果站在第n+1个盒子面前，则表示前n个盒子已经放好扑克牌
            // 输出一种排列(1~n号盒子中的扑克牌编号)
            for (i = 1; i <= n; i++) {
                console.log(a[i])
            }
            console.log('\n')
            return // 返回之前的一步(最近一次调用dfs函数的地方)
        }

        // 此时站在第step个盒子面前，应该放哪张牌呢？
        // 按照1、2、3...n的顺序一一尝试
        for (i = 1; i <= n; i++) {
            // 判断扑克牌i是否还在手上
            if (book[i] === 0) { // book[i]等于0表示i号扑克牌在手上
                // 开始尝试使用扑克牌i
                a[step] = i // 将i号扑克牌放入到第step个盒子中
                book[i] = 1 // 将book[i]设为1，表示i号扑克牌已经不在手上了

                // 第step个盒子已经放好扑克牌，接下来需要走到下一个盒子面前
                dfs(step + 1) // 这里通过函数的递归调用来实现
                book[i] = 0 // 这是非常重要的一步，一定要将刚才尝试的扑克牌收回，才能进行下一次尝试
            }
        }
    }
    dfs(1)
}

permutationNumbers(3)
